using Microsoft.Extensions.Logging;
using Nethereum.JsonRpc.WebSocketStreamingClient;
using Nethereum.RPC.Eth.DTOs;
using Nethereum.RPC.Reactive.Eth.Subscriptions;

namespace EthTestTask.Detecters
{
    /// <summary>
    /// This detector has a few drawbacks. It relies only on events generated by a smart contract. The generator
    /// supposes that the event would have somewhere in log.Topics an monitoring address.
    /// So in the next conditions we would have a false-alarm log:
    /// 1. A smart contract logged an event with a monitoring address but did not really transfer money to the monitoring address;
    /// 2. if the event look like  event TestEvent(address[] array). In this case, it won't be possible to track it in THIS implementation.
    /// </summary>
    public class TransferFromContractDetector : DetectorBase
    {
        public TransferFromContractDetector(DetectorConfiguration config, ILoggerFactory logger) : base(config, logger) { }

        protected override async Task DetectInternal(StreamingWebSocketClient client, CancellationToken cancellationToken)
        {
            var subscription = new EthLogsObservableSubscription(client);

            subscription.GetSubscriptionDataResponsesAsObservable().
                         Subscribe(EventHandler, cancellationToken);

            await client.StartAsync();
            subscription.GetSubscribeResponseAsObservable().Subscribe(id =>
                logger.LogInformation("TransferFromContractDetector subscripted with Id: {subscribptionID}", id));
            await subscription.SubscribeAsync();
        }

        private void EventHandler(FilterLog log)
        {
            try
            {
                // it supposed that the monitoring address is logged somewhere in the event
                // It tries to extract an address from a hash.
                var supposedAddresses = log.Topics.Select(
                    x =>
                        {
                            var r = (string)x;
                            return "0x" + r.Substring(r.Length - 40, 40);
                        }
                    );
                var intersect = toAddressesForMonistoring.Intersect(supposedAddresses);
                if (intersect.Any())
                {
                    foreach (var addressTo in intersect)
                    {
                        logger.LogInformation("Detected supposed incoming transfer from smart contract to {address}. txHash {txHash}",
                                addressTo, log.TransactionHash);
                    }
                }
            }
            catch (Exception ex)
            {
                logger.LogError("During decodind exception happened {message}", ex.Message);
            }
        }
    }
}
